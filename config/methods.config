PARAMS_SCHEME = [
    'sample_name': null,
    'input_csv': null,
    'output_dir': null,
    'index_dir': null,
    'entrypoint': ['gvf', 'parser', 'fasta']
]

methods {
    set_pipeline_log = {
        trace.enabled = true
        trace.file = "${params.pipeline_log_dir}/trace.txt"

        timeline.enabled = true
        timeline.file = "${params.pipeline_log_dir}/timeline.html"

        report.enabled = true
        report.file = "${params.pipeline_log_dir}/report.html"
    }

    set_output_dir = {
        tz = TimeZone.getTimeZone("UTC")
        timestamp = new Date().format("yyyyMMdd'T'HHmmss'Z'", tz)
        software = "moPepGen-${params.mopepgen_version}"
        root_output_dir = "${params.output_dir}/${manifest.name}-${manifest.version}/${params.sample_name}"

        output_dir = "${root_output_dir}/${software}"
        params.final_output_dir = "${output_dir}/output"
        params.intermediate_file_dir = "${output_dir}/intermediate"

        log_dir = "${root_output_dir}/log-${manifest.name}-${manifest.version}-${timestamp}"
        params.process_log_dir = "${log_dir}/process-log/${software}"
        params.pipeline_log_dir = "${log_dir}/nextflow-log"
    }

    check_max = { obj, type ->
        if (type == 'memory') {
            try {
                if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                    return params.max_memory as nextflow.util.MemoryUnit
                else
                    return obj
            } catch (all) {
                println "   ### ERROR ###   Max memory '${params.max_memory}' is not valid! Using default value: $obj"
                return obj
            }
        } else if (type == 'time') {
            try {
                if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                    return params.max_time as nextflow.util.Duration
                else
                    return obj
            } catch (all) {
                println "   ### ERROR ###   Max time '${params.max_time}' is not valid! Using default value: $obj"
                return obj
            }
        } else if (type == 'cpus') {
            try {
                return Math.min(obj, params.max_cpus as int)
            } catch (all) {
                println "   ### ERROR ###   Max cpus '${params.max_cpus}' is not valid! Using default value: $obj"
                return obj
            }
        }
    }

    set_resources_allocation = {
        // Function to ensure that resource requirements don't go beyond
        // a maximum limit
        node_cpus = params.max_cpus
        node_memory_GB = params.max_memory.toGiga()
        // Load base.config by default for all pipelines
        includeConfig "${projectDir}/config/base.config"
        if (params.ucla_cds) {
            // Infer SKU partition type and include node specific resources config.
            if ((node_cpus == 32) && node_memory_GB >= 60 && node_memory_GB <= 64) {
                includeConfig "${projectDir}/config/F32.config"
            } else if (node_cpus == 72 && node_memory_GB >= 130 && node_memory_GB <= 144) {
                includeConfig "${projectDir}/config/F72.config"
            } else {
                throw new Exception("   ### ERROR ###   System resources not as expected (cpus=${node_cpus} memory=${node_memory_GB}), unable to assign resources.")
            }
        }
    }

    validate = {
        PARAMS_SCHEME.each { key, val ->
            if (!(params.containsKey(key))) {
                throw new Exception("Required option `${key}` not set.")
            }
            if (val != null && val in Collection) {
                if (!(params[key] in val)) {
                    throw new Exception("${key}: ${params[key]} not supported. The supported options are: ${val}")
                }
            }
        }
        if (params.entrypoint == 'fasta') {
            if (!(params.containsKey('variant_fasta'))) {
                throw new Exception("Required option `variant_fasta` not set.")
            }
        }
        params.filter_fasta_variant = params.containsKey('filterFasta') && params['filterFasta'].containsKey('variant_peptides')
        params.filter_fasta_noncoding = params.containsKey('filterFasta') && params['filterFasta'].containsKey('noncoding_peptides')
        if (params.filter_fasta_noncoding && params.noncoding_peptides == '_NO_FILE') {
            throw new Exception('`noncoding_peptides` is not specified.')
        }
    }

    setup = {
        methods.validate()
        methods.set_output_dir()
        methods.set_pipeline_log()
        methods.set_resources_allocation()
    }
}
